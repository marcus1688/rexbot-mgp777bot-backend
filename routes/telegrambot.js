const express = require("express");
const TelegramBot = require("node-telegram-bot-api");
const cron = require("node-cron");
const router = express.Router();
const Config = require("../models/config.model");
const Transaction = require("../models/transaction.model");
const DailyReport = require("../models/report.model");
const moment = require("moment-timezone");
const SummaryService = require("../services/summaryService");

let bot = null;
const deleteConfirmations = new Map();

const initializeBot = async () => {
  if (bot) {
    console.log("ÂÅúÊ≠¢Áé∞ÊúâÁöÑ Bot ÂÆû‰æã...");
    if (process.env.NODE_ENV !== "production") {
      bot.stopPolling();
    }
    bot = null;
  }
  const token = process.env.TELEGRAM_BOT_TOKEN;

  if (!token) {
    console.error("ËØ∑Âú® .env Êñá‰ª∂‰∏≠ËÆæÁΩÆ TELEGRAM_BOT_TOKEN");
    return null;
  }
  const isProduction = process.env.NODE_ENV === "production";
  if (isProduction) {
    bot = new TelegramBot(token);
    const webhookUrl = `https://mgp777bot.luckybot7.com/webhook/${token}`;
    await bot.setWebHook(webhookUrl);
    console.log("üì± TelegramÊú∫Âô®‰∫∫Â∑≤ÂêØÂä® (Webhook Ê®°Âºè)");
    console.log("Webhook URL:", webhookUrl);
  } else {
    bot = new TelegramBot(token, { polling: true });
    console.log("üì± TelegramÊú∫Âô®‰∫∫Â∑≤ÂêØÂä® (Polling Ê®°Âºè)");
  }

  setupBotHandlers();
  return bot;
};

const getTodayString = () => {
  const now = moment().tz("Asia/Kuala_Lumpur");
  if (now.hour() < 6) {
    return now.subtract(1, "day").format("YYYY-MM-DD");
  }

  return now.format("YYYY-MM-DD");
};

const getBusinessDayRange = (dateStr) => {
  const start = moment
    .tz(dateStr, "Asia/Kuala_Lumpur")
    .hour(6)
    .minute(0)
    .second(0)
    .millisecond(0)
    .utc()
    .toDate();

  const end = moment
    .tz(dateStr, "Asia/Kuala_Lumpur")
    .add(1, "day")
    .hour(5)
    .minute(59)
    .second(59)
    .millisecond(999)
    .utc()
    .toDate();

  return { start, end };
};

const formatTime = (date = new Date()) => {
  return moment(date).tz("Asia/Kuala_Lumpur").format("HH:mm:ss");
};

const deleteTodayTransactions = async (chatId) => {
  const today = getTodayString();
  const { start, end } = getBusinessDayRange(today);

  const result = await Transaction.deleteMany({
    chatId: chatId.toString(),
    timestamp: {
      $gte: start,
      $lte: end,
    },
  });

  return result;
};

const formatNumber = (num) => {
  return num.toLocaleString("zh-CN", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 2,
  });
};

const getConfig = async (chatId) => {
  let config = await Config.findOne({ chatId: chatId.toString() });
  if (!config) {
    config = new Config({ chatId: chatId.toString() });
    await config.save();
  }
  return config;
};

const getTodayTransactions = async (chatId) => {
  const today = getTodayString();
  const { start, end } = getBusinessDayRange(today);
  return await Transaction.find({
    chatId: chatId.toString(),
    timestamp: {
      $gte: start,
      $lte: end,
    },
  }).sort({ timestamp: 1 });
};

const calculateStats = (transactions, currentFeeRate) => {
  const ÂÖ•Ê¨æ = transactions.filter((t) => t.type === "ÂÖ•Ê¨æ");
  const ‰∏ãÂèë = transactions.filter((t) => t.type === "‰∏ãÂèë");
  const ‰ª£‰ªò = transactions.filter((t) => t.type === "‰ª£‰ªò");
  const totalInAmount = ÂÖ•Ê¨æ.reduce((sum, t) => sum + t.amount, 0);
  const totalInUsdt = ÂÖ•Ê¨æ.reduce((sum, t) => sum + t.amount / t.rate, 0);
  const totalOutUsdt = ‰∏ãÂèë.reduce((sum, t) => sum + t.usdt, 0);
  const totalActualUsdt = ÂÖ•Ê¨æ.reduce((sum, t) => {
    const feeRate = t.feeRate !== undefined ? t.feeRate : currentFeeRate;
    return sum + (t.amount / t.rate) * (1 - feeRate / 100);
  }, 0);
  const totalPayoutUsdt = ‰ª£‰ªò.reduce((sum, t) => sum + t.usdt, 0);
  const totalPayoutAmount = ‰ª£‰ªò.reduce((sum, t) => sum + t.amount, 0);
  const adjustedActualUsdt = totalActualUsdt - totalPayoutUsdt;
  return {
    ÂÖ•Ê¨æ,
    ‰∏ãÂèë,
    ‰ª£‰ªò,
    totalInAmount,
    totalInUsdt,
    totalOutUsdt,
    totalActualUsdt,
    totalPayoutUsdt,
    totalPayoutAmount,
    adjustedActualUsdt,
  };
};

const generateTelegramLink = (chatId, messageId) => {
  const chatIdStr = chatId.toString();
  if (chatIdStr.startsWith("-100")) {
    const groupId = chatIdStr.slice(4);
    return `https://t.me/c/${groupId}/${messageId}`;
  } else {
    const groupId = Math.abs(parseInt(chatId));
    return `https://t.me/c/${groupId}/${messageId}`;
  }
};

const formatReport = async (chatId, newTransactionId = null) => {
  try {
    const config = await getConfig(chatId);
    const transactions = await getTodayTransactions(chatId);
    const stats = calculateStats(transactions, config.feeRate);
    const ÂÖ•Ê¨æÊòæÁ§∫ = stats.ÂÖ•Ê¨æ.slice(-10);
    const ‰ª£‰ªòÊòæÁ§∫ = stats.‰ª£‰ªò.slice(-10);
    const ‰∏ãÂèëÊòæÁ§∫ = stats.‰∏ãÂèë.slice(-10);
    let report = `‰ªäÊó•ÂÖ•Ê¨æÔºà${stats.ÂÖ•Ê¨æ.length}Á¨îÔºâ\n`;
    if (stats.ÂÖ•Ê¨æ.length === 0) {
      report += `ÊöÇÊó†ÂÖ•Ê¨æËÆ∞ÂΩï\n`;
    } else {
      if (stats.ÂÖ•Ê¨æ.length > 10) {
        report += `*ÊòæÁ§∫ÊúÄÊñ∞10Á¨îÔºåÂÖ±${stats.ÂÖ•Ê¨æ.length}Á¨î*\n`;
      }
      ÂÖ•Ê¨æÊòæÁ§∫.forEach((t) => {
        const time = formatTime(t.timestamp);
        const feeRate = t.feeRate !== undefined ? t.feeRate : config.feeRate;
        const actualUsdt = (t.amount / t.rate) * (1 - feeRate / 100);
        const feeAmount = (t.amount * feeRate) / 100;
        const idLink = t.messageId ? `<code>${t.messageId}</code>` : `ID`;

        if (newTransactionId && t._id.toString() === newTransactionId) {
          report += `${t.messageId} ${time}  ${formatNumber(t.amount)} / ${
            t.rate
          } * (${(1 - feeRate / 100)
            .toFixed(4)
            .replace(/\.?0+$/, "")})=${actualUsdt.toFixed(
            2
          )}U ÊâãÁª≠(${formatNumber(feeAmount)})\n`;
        } else {
          const amountLink = t.messageId
            ? `<a href="${generateTelegramLink(
                chatId,
                t.messageId
              )}">${formatNumber(t.amount)}</a>`
            : `${formatNumber(t.amount)}`;
          let identifier = "";
          if (t.remark) {
            identifier = `(${t.remark})`;
          } else if (t.displayName) {
            identifier = t.username
              ? `<a href="https://t.me/${t.username}">${t.displayName}</a>`
              : t.displayName;
          }
          report += `${idLink} ${time}  ${amountLink} / ${t.rate} * (${(
            1 -
            feeRate / 100
          )
            .toFixed(4)
            .replace(/\.?0+$/, "")})=${actualUsdt.toFixed(2)}U ${identifier}\n`;
        }
      });
    }

    report += `\n‰ªäÊó•‰ª£‰ªòÔºà${stats.‰ª£‰ªò.length}Á¨îÔºâ\n`;

    if (stats.‰ª£‰ªò.length === 0) {
      report += `ÊöÇÊó†‰ª£‰ªòËÆ∞ÂΩï\n`;
    } else {
      if (stats.‰ª£‰ªò.length > 10) {
        report += `*ÊòæÁ§∫ÊúÄÊñ∞10Á¨îÔºåÂÖ±${stats.‰ª£‰ªò.length}Á¨î*\n`;
      }
      ‰ª£‰ªòÊòæÁ§∫.forEach((t) => {
        const time = formatTime(t.timestamp);
        const idLink = t.messageId ? `<code>${t.messageId}</code>` : `ID`;
        const amountLink = t.messageId
          ? `<a href="${generateTelegramLink(
              chatId,
              t.messageId
            )}">${formatNumber(t.amount)}</a>`
          : `${formatNumber(t.amount)}`;

        let identifier = "";
        if (t.remark) {
          identifier = `(${t.remark})`;
        } else if (t.displayName) {
          identifier = t.username
            ? `<a href="https://t.me/${t.username}">${t.displayName}</a>`
            : t.displayName;
        }

        report += `${idLink} ${time}  ${amountLink}/${t.rate}+${
          config.handlingFee
        }U=${t.usdt.toFixed(2)}U ${identifier}\n`;
      });
      report += `\n‰ª£‰ªòÊÄªÈ¢ùÔºö${formatNumber(stats.totalPayoutAmount)}\n`;
    }

    report += `\n‰ªäÊó•‰∏ãÂèëÔºà${stats.‰∏ãÂèë.length}Á¨îÔºâ\n`;
    if (stats.‰∏ãÂèë.length === 0) {
      report += `ÊöÇÊó†‰∏ãÂèëËÆ∞ÂΩï\n`;
    } else {
      if (stats.‰∏ãÂèë.length > 10) {
        report += `*ÊòæÁ§∫ÊúÄÊñ∞10Á¨îÔºåÂÖ±${stats.‰∏ãÂèë.length}Á¨î*\n`;
      }
      ‰∏ãÂèëÊòæÁ§∫.forEach((t) => {
        const time = formatTime(t.timestamp);
        const idLink = t.messageId ? `<code>${t.messageId}</code>` : `ID`;
        const usdtLink = t.messageId
          ? `<a href="${generateTelegramLink(chatId, t.messageId)}">${
              t.usdt
            }U</a>`
          : `${t.usdt}U`;
        let identifier = "";
        if (t.remark) {
          identifier = `(${t.remark})`;
        } else if (t.displayName) {
          identifier = t.username
            ? `<a href="https://t.me/${t.username}">${t.displayName}</a>`
            : t.displayName;
        }

        report += `${idLink} ${time}  ${usdtLink} ${identifier}\n`;
      });
    }

    report += `\nÊÄªÂÖ•Ê¨æÔºö${formatNumber(
      stats.totalInAmount
    )} (${stats.totalInUsdt.toFixed(2)}U)\n`;
    report += `ÂΩìÂâçË¥πÁéáÔºö${config.feeRate}%\n`;
    report += `Ê±áÁéáÔºö${config.inRate}\n`;
    report += `‰ª£‰ªòÂçïÁ¨îÊâãÁª≠Ë¥πÔºö${config.handlingFee}\n`;
    report += `‰∏ãÂèëÊ±áÁéáÔºö${config.outRate}\n`;

    const adjustedActualUsdt = Math.floor(stats.adjustedActualUsdt * 100) / 100;
    report += `\nÂ∫î‰∏ãÂèëÔºö${adjustedActualUsdt.toFixed(2)}U\n`;

    const outUsdt = Math.floor(stats.totalOutUsdt * 100) / 100;
    report += `Â∑≤‰∏ãÂèëÔºö${outUsdt.toFixed(2)}U\n`;

    const unDispensed =
      Math.floor((stats.adjustedActualUsdt - stats.totalOutUsdt) * 100) / 100;
    report += `Êú™‰∏ãÂèëÔºö${unDispensed.toFixed(2)}U`;

    return report;
  } catch (error) {
    console.error("Ê†ºÂºèÂåñÊä•ÂëäÈîôËØØ:", error);
    return "ÁîüÊàêÊä•ÂëäÊó∂Âá∫Áé∞ÈîôËØØ";
  }
};

const sendReportWithButton = (chatId, report) => {
  const urlSafeChatId = Math.abs(parseInt(chatId));
  const keyboard = {
    inline_keyboard: [
      [
        {
          text: "üåçÂÆåÊï¥Ë¥¶Âçï",
          url: `https://luckybot7.com/report/${urlSafeChatId}?bot=mgp777`,
        },
      ],
    ],
  };
  return bot.sendMessage(chatId, report, {
    parse_mode: "HTML",
    reply_markup: keyboard,
    disable_web_page_preview: true,
  });
};

const OWNER_IDS = [
  5342992954, 7901434688, 7849481867, 6900459191, 7668035205, 7739890736,
  8383250846, 2129732648, 786344763,
];

// const checkPermission = async (chatId, userId) => {
//   try {
//     const config = await getConfig(chatId);
//     const user = await bot.getChatMember(chatId, userId);
//     console.log(user);
//     return (
//       OWNER_IDS.includes(userId) ||
//       config.operators.includes(user.user.username)
//     );
//   } catch (error) {
//     console.error("ÊùÉÈôêÊ£ÄÊü•ÈîôËØØ:", error);
//     return false;
//   }
// };

const checkPermission = async (chatId, userId, msg = null) => {
  try {
    if (OWNER_IDS.includes(userId)) {
      return true;
    }

    const config = await getConfig(chatId);
    if (!config.operators || config.operators.length === 0) {
      return false;
    }

    if (msg && msg.from && msg.from.username) {
      return config.operators.includes(msg.from.username);
    }

    console.log(`Áî®Êà∑ ${userId} Ê≤°Êúâusername‰ø°ÊÅØÔºåÊãíÁªùÊùÉÈôê`);
    return false;
  } catch (error) {
    console.error("ÊùÉÈôêÊ£ÄÊü•ÈîôËØØ:", error);
    return false;
  }
};

const setupBotHandlers = () => {
  bot.on("polling_error", (error) => {
    console.error("Polling error:", error);
  });

  bot.on("my_chat_member", async (update) => {
    const chatId = update.chat.id;
    const newStatus = update.new_chat_member.status;
    const oldStatus = update.old_chat_member.status;
    const addedBy = update.from.id;
    const addedByUsername = update.from.username;
    if (
      (oldStatus === "left" &&
        (newStatus === "member" || newStatus === "administrator")) ||
      (oldStatus === "kicked" &&
        (newStatus === "member" || newStatus === "administrator"))
    ) {
      const keyboard = {
        inline_keyboard: [
          [
            {
              text: "üì± Ëé∑ÂèñÊàëÁöÑ Telegram ID",
              url: "https://t.me/userinfobot",
            },
          ],
        ],
      };

      const isAuthorized = OWNER_IDS.includes(addedBy);
      if (isAuthorized) {
        const welcomeKeyboard = {
          inline_keyboard: [
            [
              {
                text: "üìñ Êü•Áúã‰ΩøÁî®ËØ¥Êòé",
                callback_data: "show_help",
              },
              {
                text: "üì± Ëé∑Âèñ Telegram ID",
                url: "https://t.me/userinfobot",
              },
            ],
          ],
        };

        await bot.sendMessage(
          chatId,
          `üéâ Êú∫Âô®‰∫∫Â∑≤ÂºÄÂêØÔºåËØ∑ÂºÄÂßãËÆ∞Ë¥¶\n\n` +
            `Ê∑ªÂä†ËÄÖ‰ø°ÊÅØÔºö\n` +
            `Áî®Êà∑Âêç: @${addedByUsername || "Êú™ËÆæÁΩÆ"}\n` +
            `Áî®Êà∑ ID: ${addedBy}\n` +
            `Áä∂ÊÄÅ: ‚úÖ Â∑≤ÊéàÊùÉ\n\n` +
            `ÁÇπÂáª‰∏ãÊñπÊåâÈíÆÊü•Áúã‰ΩøÁî®ËØ¥ÊòéÊàñËé∑Âèñ ID ‰ø°ÊÅØ`,
          {
            reply_markup: welcomeKeyboard,
          }
        );

        console.log(
          `Bot Ë¢´ÊéàÊùÉÁî®Êà∑ ${addedBy} (@${addedByUsername}) Ê∑ªÂä†Âà∞Áæ§ÁªÑ ${chatId}`
        );
        await getConfig(chatId);
      } else {
        await bot.sendMessage(
          chatId,
          `‚ö†Ô∏è Ê≠§ Bot ‰ªÖ‰æõÊéàÊùÉ‰ΩøÁî®\n\n` +
            `ÊÇ®ÁöÑ‰ø°ÊÅØÔºö\n` +
            `Áî®Êà∑Âêç: @${addedByUsername || "Êú™ËÆæÁΩÆ"}\n` +
            `Áî®Êà∑ ID: ${addedBy}\n` +
            `Áä∂ÊÄÅ: ‚ùå Êú™ÊéàÊùÉ\n\n` +
            `Â¶ÇÈúÄÊéàÊùÉÔºåËØ∑Â∞ÜÊÇ®ÁöÑ ID ÂèëÈÄÅÁªô Bot ÁÆ°ÁêÜÂëò\n` +
            `ÁÇπÂáª‰∏ãÊñπÊåâÈíÆÂèØÈÄöËøá @userinfobot Êü•ÁúãÊÇ®ÁöÑËØ¶ÁªÜ‰ø°ÊÅØ`,
          {
            reply_markup: keyboard,
          }
        );
        console.log(`Êú™ÊéàÊùÉÁî®Êà∑Â∞ùËØïÊ∑ªÂä† BotÔºö`);
        console.log(`  Áî®Êà∑Âêç: @${addedByUsername || "Êú™ËÆæÁΩÆ"}`);
        console.log(`  Áî®Êà∑ ID: ${addedBy}`);
        console.log(`  Áæ§ÁªÑ ID: ${chatId}`);
        setTimeout(async () => {
          await bot.sendMessage(chatId, "Bot Â∞ÜËá™Âä®Á¶ªÂºÄÊú™ÊéàÊùÉÁöÑÁæ§ÁªÑ");
          await bot.leaveChat(chatId);
        }, 5000);
      }
    }
  });
  bot.on("callback_query", async (callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    const data = callbackQuery.data;
    if (data === "show_help") {
      if (!(await checkPermission(chatId, userId))) {
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•Êü•ÁúãÂ∏ÆÂä©",
          show_alert: true,
        });
        return;
      }
      const helpText = `
ü§ñ Êú∫Âô®‰∫∫‰ΩøÁî®ËØ¥Êòé

ÁÆ°ÁêÜÂëòÂëΩ‰ª§Ôºö
- ËÆæÁΩÆË¥πÁéá[Êï∞Â≠ó] - ËÆæÁΩÆ‰∫§ÊòìË¥πÁéá
- ËÆæÁΩÆÊ±áÁéá[Êï∞Â≠ó] - ËÆæÁΩÆÊ±áÁéá  
- ËÆæÁΩÆÂá∫Ê¨æÊ±áÁéá[Êï∞Â≠ó] - ËÆæÁΩÆÂá∫Ê¨æÊ±áÁéá
- ËÆæÁΩÆÊâãÁª≠Ë¥π[Êï∞Â≠ó] - ËÆæÁΩÆÂçïÁ¨îÊâãÁª≠Ë¥π
- ËÆæÁΩÆÊìç‰ΩúÂëò @Áî®Êà∑Âêç - Ê∑ªÂä†Êìç‰ΩúÂëò
- ‰∏äËØæ - ÂºÄÂßãËê•‰∏ö
- ‰∏ãËØæ - ÁªìÊùüËê•‰∏ö
- Êí§ÈîÄ[Ê∂àÊÅØID] - Êí§ÈîÄÊåáÂÆö‰∫§Êòì
- Âà†Èô§Ë¥¶Âçï - Âà†Èô§‰ªäÊó•ÊâÄÊúâ‰∫§ÊòìËÆ∞ÂΩï

‰∫§ÊòìÂëΩ‰ª§Ôºö
- +[ÈáëÈ¢ù] Êàñ +[ÈáëÈ¢ù] (Â§áÊ≥®) - ËÆ∞ÂΩïÂÖ•Ê¨æ
- ‰∏ãÂèë[USDTÈáëÈ¢ù] Êàñ ‰∏ãÂèë[USDTÈáëÈ¢ù] (Â§áÊ≥®) - ËÆ∞ÂΩï‰∏ãÂèë
- F[ÈáëÈ¢ù] Êàñ F[ÈáëÈ¢ù] (Â§áÊ≥®) - ‰ª£‰ªòËÆ°ÁÆó

Êü•ËØ¢ÂëΩ‰ª§Ôºö
- Áä∂ÊÄÅ - Êü•Áúã‰ªäÊó•Êä•Âëä
- [Êï∞Â≠ó][+-*/][Êï∞Â≠ó] - ËÆ°ÁÆóÂô®

Á§∫‰æãÔºö
- ËÆæÁΩÆË¥πÁéá2
- +1000000 Êàñ +1000000 (Â∑•ËµÑ)
- ‰∏ãÂèë59.39 Êàñ ‰∏ãÂèë-100 (Ë∞ÉÊï¥)
- F1000000 Êàñ F-500000 (ÈÄÄÊ¨æ)
- Êí§ÈîÄ126
- Âà†Èô§Ë¥¶Âçï
- 100+200
`;
      await bot.sendMessage(chatId, helpText);
      await bot.answerCallbackQuery(callbackQuery.id);
    }
  });

  bot.on("message", async (msg) => {
    const text = (msg.text || msg.caption || "").trim();
    if (!text) return;

    const chatId = msg.chat.id;
    const username = msg.from.username;
    const messageId = msg.message_id;
    const userId = msg.from.id;

    try {
      const config = await getConfig(chatId);

      if (text.match(/^ËÆæÁΩÆË¥πÁéá\s*(\d+\.?\d*)$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•ËÆæÁΩÆË¥πÁéá");
          return;
        }

        const rate = parseFloat(text.match(/^ËÆæÁΩÆË¥πÁéá\s*(\d+\.?\d*)$/)[1]);
        if (rate < 0 || rate > 100) {
          bot.sendMessage(chatId, "‚ùå Ë¥πÁéáÂøÖÈ°ªÂú®0-100%‰πãÈó¥");
          return;
        }
        config.feeRate = rate;
        await config.save();
        bot.sendMessage(chatId, `Ë¥πÁéáËÆæÁΩÆÊàêÂäüÔºåÂΩìÂâç‰∫§ÊòìË¥πÁéá‰∏∫Ôºö${rate}%`);
        return;
      }

      if (text.match(/^ËÆæÁΩÆÊ±áÁéá\s*(\d+\.?\d*)$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•ËÆæÁΩÆÊ±áÁéá");
          return;
        }
        const rate = parseFloat(text.match(/^ËÆæÁΩÆÊ±áÁéá\s*(\d+\.?\d*)$/)[1]);
        if (rate <= 0) {
          bot.sendMessage(chatId, "‚ùå Ê±áÁéáÂøÖÈ°ªÂ§ß‰∫é0");
          return;
        }
        config.inRate = rate;
        await config.save();
        bot.sendMessage(chatId, `Ê±áÁéáËÆæÁΩÆÊàêÂäüÔºåÂΩìÂâçÊ±áÁéá‰∏∫Ôºö${rate}`);
        return;
      }

      if (text.match(/^ËÆæÁΩÆÂá∫Ê¨æÊ±áÁéá\s*(\d+\.?\d*)$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•ËÆæÁΩÆÊ±áÁéá");
          return;
        }
        const rate = parseFloat(text.match(/^ËÆæÁΩÆÂá∫Ê¨æÊ±áÁéá\s*(\d+\.?\d*)$/)[1]);
        if (rate <= 0) {
          bot.sendMessage(chatId, "‚ùå Ê±áÁéáÂøÖÈ°ªÂ§ß‰∫é0");
          return;
        }
        config.outRate = rate;
        await config.save();
        bot.sendMessage(chatId, `Âá∫Ê¨æÊ±áÁéáËÆæÁΩÆÊàêÂäüÔºåÂΩìÂâçÂá∫Ê¨æÊ±áÁéá‰∏∫Ôºö${rate}`);
        return;
      }

      if (text.match(/^ËÆæÁΩÆÊâãÁª≠Ë¥π\s*(\d+\.?\d*)$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•ËÆæÁΩÆÊâãÁª≠Ë¥π");
          return;
        }
        const fee = parseFloat(text.match(/^ËÆæÁΩÆÊâãÁª≠Ë¥π\s*(\d+\.?\d*)$/)[1]);
        if (fee < 0) {
          bot.sendMessage(chatId, "‚ùå ÊâãÁª≠Ë¥π‰∏çËÉΩ‰∏∫Ë¥üÊï∞");
          return;
        }
        config.handlingFee = fee;
        await config.save();
        bot.sendMessage(chatId, `ÊâãÁª≠Ë¥πËÆæÁΩÆÊàêÂäüÔºåÂΩìÂâçÊâãÁª≠Ë¥π‰∏∫Ôºö${fee}`);
        return;
      }

      if (text.match(/^ËÆæÁΩÆÊìç‰ΩúÂëò\s+(.+)$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•ËÆæÁΩÆÊìç‰ΩúÂëò");
          return;
        }
        const operatorsText = text.match(/^ËÆæÁΩÆÊìç‰ΩúÂëò\s+(.+)$/)[1];
        const operators = operatorsText.match(/@?\w+/g) || [];
        const cleanedOperators = operators.map((op) => op.replace("@", ""));
        const newOperators = cleanedOperators.filter(
          (op) => !config.operators.includes(op)
        );
        const existingOperators = cleanedOperators.filter((op) =>
          config.operators.includes(op)
        );

        if (newOperators.length > 0) {
          config.operators.push(...newOperators);
          await config.save();
          let message = `‚úÖ ÊàêÂäüÊ∑ªÂä† ${newOperators.length} ‰∏™Êìç‰ΩúÂëòÔºö\n`;
          message += newOperators.map((op) => `@${op}`).join(", ");
          if (existingOperators.length > 0) {
            message += `\n\n‚ö†Ô∏è ‰ª•‰∏ãÊìç‰ΩúÂëòÂ∑≤Â≠òÂú®Ôºö\n`;
            message += existingOperators.map((op) => `@${op}`).join(", ");
          }
          bot.sendMessage(chatId, message);
        } else {
          bot.sendMessage(chatId, `‚ö†Ô∏è ÊâÄÊúâÊìç‰ΩúÂëòÈÉΩÂ∑≤Â≠òÂú®ÔºåÊó†ÈúÄÈáçÂ§çÊ∑ªÂä†`);
        }
        return;
      }

      if (text === "Êü•ÁúãÊìç‰ΩúÂëò") {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Êü•ÁúãÊìç‰ΩúÂëò");
          return;
        }
        if (config.operators.length === 0) {
          bot.sendMessage(chatId, "ÂΩìÂâçÊ≤°ÊúâËÆæÁΩÆ‰ªª‰ΩïÊìç‰ΩúÂëò");
        } else {
          let message = `üìã ÂΩìÂâçÊìç‰ΩúÂëòÂàóË°®ÔºàÂÖ± ${config.operators.length} ‰∫∫ÔºâÔºö\n\n`;
          message += config.operators
            .map((op, index) => `${index + 1}. @${op}`)
            .join("\n");
          bot.sendMessage(chatId, message);
        }
        return;
      }

      if (text.match(/^Âà†Èô§Êìç‰ΩúÂëò\s+(.+)$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Âà†Èô§Êìç‰ΩúÂëò");
          return;
        }
        const operatorsText = text.match(/^Âà†Èô§Êìç‰ΩúÂëò\s+(.+)$/)[1];
        const operators = operatorsText.match(/@?\w+/g) || [];
        const cleanedOperators = operators.map((op) => op.replace("@", ""));
        const deletedOperators = [];
        const notFoundOperators = [];
        cleanedOperators.forEach((op) => {
          const index = config.operators.indexOf(op);
          if (index > -1) {
            config.operators.splice(index, 1);
            deletedOperators.push(op);
          } else {
            notFoundOperators.push(op);
          }
        });
        if (deletedOperators.length > 0) {
          await config.save();
          let message = `‚úÖ ÊàêÂäüÂà†Èô§ ${deletedOperators.length} ‰∏™Êìç‰ΩúÂëòÔºö\n`;
          message += deletedOperators.map((op) => `@${op}`).join(", ");
          if (notFoundOperators.length > 0) {
            message += `\n\n‚ö†Ô∏è ‰ª•‰∏ãÊìç‰ΩúÂëò‰∏çÂ≠òÂú®Ôºö\n`;
            message += notFoundOperators.map((op) => `@${op}`).join(", ");
          }
          bot.sendMessage(chatId, message);
        } else {
          bot.sendMessage(chatId, `‚ùå Ê≤°ÊúâÊâæÂà∞‰ªª‰ΩïÈúÄË¶ÅÂà†Èô§ÁöÑÊìç‰ΩúÂëò`);
        }
        return;
      }

      if (text === "Ê∏ÖÁ©∫Êìç‰ΩúÂëò") {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Ê∏ÖÁ©∫Êìç‰ΩúÂëò");
          return;
        }
        if (config.operators.length === 0) {
          bot.sendMessage(chatId, "ÂΩìÂâçÊ≤°Êúâ‰ªª‰ΩïÊìç‰ΩúÂëò");
        } else {
          const count = config.operators.length;
          config.operators = [];
          await config.save();
          bot.sendMessage(chatId, `‚úÖ Â∑≤Ê∏ÖÁ©∫ÊâÄÊúâ ${count} ‰∏™Êìç‰ΩúÂëò`);
        }
        return;
      }

      if (text === "‰∏äËØæ") {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•Êìç‰ΩúËê•‰∏öÁä∂ÊÄÅ");
          return;
        }
        config.isOpen = true;
        await config.save();
        bot.sendMessage(chatId, "Êú¨Áæ§Â∑≤ÂºÄÂßãËê•‰∏ö");
        return;
      }

      if (text === "‰∏ãËØæ") {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•Êìç‰ΩúËê•‰∏öÁä∂ÊÄÅ");
          return;
        }
        config.isOpen = false;
        await config.save();
        bot.sendMessage(
          chatId,
          "Êú¨Áæ§‰ªäÊó•Â∑≤‰∏ãËØæÔºå\nÂ¶ÇÈúÄ‰∫§ÊòìÔºåËØ∑Âú®ËØ•Áæ§ÊÅ¢Â§çËê•‰∏öÂêéÂú®Áæ§ÂÜÖ‰∫§ÊòìÔºÅ ÂàáÂãøÁßÅ‰∏ã‰∫§ÊòìÔºÅÔºÅÔºÅ\nÂ¶ÇÊúâ‰∏öÂä°Âí®ËØ¢ËØ∑ËÅîÁ≥ªÁæ§ËÄÅÊùø/‰∏öÂä°Âëò"
        );
        return;
      }

      if (text === "Áä∂ÊÄÅ" || text === "status" || text === "+0") {
        const report = await formatReport(chatId);
        sendReportWithButton(chatId, report);
        return;
      }

      if (text.match(/^\+(\d+)(\s*[\(Ôºà](.+)[\)Ôºâ])?$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•ËÆ∞ÂΩï‰∫§Êòì");
          return;
        }
        if (!config.inRate || config.inRate === 0) {
          bot.sendMessage(chatId, "‚ùå ËØ∑ÂÖàËÆæÁΩÆÊ±áÁéáÔºåÂΩìÂâçÊ±áÁéá‰∏∫0");
          return;
        }
        const match = text.match(/^\+(\d+)(\s*[\(Ôºà](.+)[\)Ôºâ])?$/);
        const amount = parseInt(match[1]);
        const remark = match[3] || null;

        if (amount <= 0) {
          bot.sendMessage(chatId, "‚ùå ÂÖ•Ê¨æÈáëÈ¢ùÂøÖÈ°ªÂ§ß‰∫é0");
          return;
        }

        const calculatedUsdt =
          (amount / config.inRate) * (1 - config.feeRate / 100);

        const displayName = `${msg.from.first_name}${
          msg.from.last_name ? " " + msg.from.last_name : ""
        }`;

        const transaction = new Transaction({
          chatId: chatId.toString(),
          groupName: msg.chat.title || msg.chat.username || "Private Chat",
          type: "ÂÖ•Ê¨æ",
          amount,
          rate: config.inRate,
          feeRate: config.feeRate,
          messageId,
          username,
          displayName: displayName,
          remark: remark,
          userId: userId,
          date: getTodayString(),
          calculatedUsdt,
        });

        await transaction.save();
        await SummaryService.updateSummaryOnTransaction(transaction, config);
        const report = await formatReport(chatId, transaction._id.toString());
        sendReportWithButton(chatId, report);
        return;
      }

      if (text.match(/^‰∏ãÂèë\s*(-?\d+\.?\d*)(\s*[\(Ôºà](.+)[\)Ôºâ])?$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•ËÆ∞ÂΩï‰∏ãÂèë");
          return;
        }
        const match = text.match(
          /^‰∏ãÂèë\s*(-?\d+\.?\d*)(\s*[\(Ôºà](.+)[\)Ôºâ])?$/
        );
        const usdt = parseFloat(match[1]);
        const remark = match[3] || null;

        if (usdt === 0) {
          bot.sendMessage(chatId, "‚ùå ‰∏ãÂèëÈáëÈ¢ù‰∏çËÉΩ‰∏∫0");
          return;
        }

        const displayName = `${msg.from.first_name}${
          msg.from.last_name ? " " + msg.from.last_name : ""
        }`;

        const transaction = new Transaction({
          chatId: chatId.toString(),
          groupName: msg.chat.title || msg.chat.username || "Private Chat",
          type: "‰∏ãÂèë",
          usdt,
          messageId,
          username,
          displayName: displayName,
          remark: remark,
          userId: userId,
          date: getTodayString(),
        });

        await transaction.save();
        await SummaryService.updateSummaryOnTransaction(transaction, config);
        const report = await formatReport(chatId);
        sendReportWithButton(chatId, report);
        return;
      }

      if (text.match(/^(\d+\.?\d*)\s*([\+\-\*\/])\s*(\d+\.?\d*)$/)) {
        const match = text.match(/^(\d+\.?\d*)\s*([\+\-\*\/])\s*(\d+\.?\d*)$/);
        const num1 = parseFloat(match[1]);
        const operator = match[2];
        const num2 = parseFloat(match[3]);

        if (operator === "/" && num2 === 0) {
          bot.sendMessage(chatId, "‚ùå Èô§Êï∞‰∏çËÉΩ‰∏∫0");
          return;
        }

        let result;
        switch (operator) {
          case "+":
            result = num1 + num2;
            break;
          case "-":
            result = num1 - num2;
            break;
          case "*":
            result = num1 * num2;
            break;
          case "/":
            result = num1 / num2;
            break;
        }

        bot.sendMessage(chatId, `${text}=${formatNumber(result)}`);
        return;
      }

      if (text.match(/^[\d\.\+\-\*\/\s]+$/)) {
        try {
          const expression = text.replace(/\s/g, "");
          const tokens = expression.match(/(\d+\.?\d*|[\+\-\*\/])/g);
          if (!tokens || tokens.length < 3 || tokens.length % 2 === 0) {
            // bot.sendMessage(chatId, "‚ùå Ë°®ËææÂºèÊ†ºÂºèÈîôËØØ");
            return;
          }
          for (let i = 0; i < tokens.length; i++) {
            if (i % 2 === 0) {
              if (!/^\d+\.?\d*$/.test(tokens[i])) {
                // bot.sendMessage(chatId, "‚ùå Ë°®ËææÂºèÊ†ºÂºèÈîôËØØ");
                return;
              }
            } else {
              if (!/^[\+\-\*\/]$/.test(tokens[i])) {
                // bot.sendMessage(chatId, "‚ùå Ë°®ËææÂºèÊ†ºÂºèÈîôËØØ");
                return;
              }
            }
          }
          let result = evaluateExpression(tokens);
          bot.sendMessage(chatId, `${text} = ${formatNumber(result)}`);
          return;
        } catch (error) {
          bot.sendMessage(chatId, "‚ùå ËÆ°ÁÆóÂá∫Èîô");
          return;
        }
      }

      if (text.match(/^[Ff]\s*(-?\d+\.?\d*)(\s*[\(Ôºà](.+)[\)Ôºâ])?$/)) {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊìç‰ΩúÂëòÂèØ‰ª•ËÆ∞ÂΩï‰ª£‰ªò");
          return;
        }
        if (!config.outRate || config.outRate === 0) {
          bot.sendMessage(chatId, "‚ùå ËØ∑ÂÖàËÆæÁΩÆÂá∫Ê¨æÊ±áÁéáÔºåÂΩìÂâçÂá∫Ê¨æÊ±áÁéá‰∏∫0");
          return;
        }

        const match = text.match(
          /^[Ff]\s*(-?\d+\.?\d*)(\s*[\(Ôºà](.+)[\)Ôºâ])?$/
        );
        const amount = parseFloat(match[1]);
        const remark = match[3] || null;

        if (amount <= 0) {
          bot.sendMessage(chatId, "‚ùå ‰ª£‰ªòÈáëÈ¢ùÂøÖÈ°ªÂ§ß‰∫é0");
          return;
        }

        const result = amount / config.outRate + config.handlingFee;
        const displayName = `${msg.from.first_name}${
          msg.from.last_name ? " " + msg.from.last_name : ""
        }`;

        const transaction = new Transaction({
          chatId: chatId.toString(),
          groupName: msg.chat.title || msg.chat.username || "Private Chat",
          type: "‰ª£‰ªò",
          amount: amount,
          usdt: result,
          rate: config.outRate,
          messageId,
          username,
          displayName: displayName,
          remark: remark,
          userId: userId,
          date: getTodayString(),
        });

        await transaction.save();
        await SummaryService.updateSummaryOnTransaction(transaction, config);
        const transactions = await getTodayTransactions(chatId);
        const stats = calculateStats(transactions, config.feeRate);
        const adjustedActualUsdt =
          Math.floor(stats.adjustedActualUsdt * 100) / 100;
        const outUsdt = Math.floor(stats.totalOutUsdt * 100) / 100;
        const unDispensed =
          Math.floor((stats.adjustedActualUsdt - stats.totalOutUsdt) * 100) /
          100;
        const totalPayoutAmount = stats.‰ª£‰ªò.reduce(
          (sum, t) => sum + t.amount,
          0
        );
        let message = `F${formatNumber(amount)}\n`;
        message += `Â∫î‰∏ãÂèëÔºö${adjustedActualUsdt.toFixed(2)}U\n`;
        message += `Â∑≤‰∏ãÂèëÔºö${outUsdt.toFixed(2)}U\n`;
        message += `Êú™‰∏ãÂèëÔºö${unDispensed.toFixed(2)}U`;

        if (remark) {
          message = `F${formatNumber(amount)} (${remark})\n`;
          message += `Â∫î‰∏ãÂèëÔºö${adjustedActualUsdt.toFixed(2)}U\n`;
          message += `Â∑≤‰∏ãÂèëÔºö${outUsdt.toFixed(2)}U\n`;
          message += `Êú™‰∏ãÂèëÔºö${unDispensed.toFixed(2)}U`;
        }

        // bot.sendMessage(chatId, message);
        const report = await formatReport(chatId);
        sendReportWithButton(chatId, report);
        return;
      }

      if (text.match(/^Êí§ÈîÄ(\d+)$/)) {
        const messageId = parseInt(text.match(/^Êí§ÈîÄ(\d+)$/)[1]);
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂèØ‰ª•Êí§ÈîÄ‰∫§Êòì");
          return;
        }
        const today = getTodayString();
        const { start, end } = getBusinessDayRange(today);
        const transaction = await Transaction.findOne({
          messageId: messageId,
          chatId: chatId.toString(),
          timestamp: {
            $gte: start,
            $lte: end,
          },
        });
        if (transaction) {
          const type = transaction.type;
          const amount =
            transaction.type === "ÂÖ•Ê¨æ"
              ? formatNumber(transaction.amount)
              : transaction.usdt + "U";
          await SummaryService.reverseTransaction(transaction, config);
          await Transaction.deleteOne({ _id: transaction._id });
          const report = await formatReport(chatId);
          bot.sendMessage(chatId, `Â∑≤Êí§ÈîÄ${type} ${amount}\n\n${report}`, {
            parse_mode: "HTML",
            disable_web_page_preview: true,
          });
        } else {
          bot.sendMessage(chatId, "Êâæ‰∏çÂà∞ËØ•‰∫§ÊòìËÆ∞ÂΩï");
        }
        return;
      }

      if (text === "/help" || text === "Â∏ÆÂä©") {
        const helpText = `
ü§ñ Êú∫Âô®‰∫∫‰ΩøÁî®ËØ¥Êòé

ÁÆ°ÁêÜÂëòÂëΩ‰ª§Ôºö
- ËÆæÁΩÆË¥πÁéá[Êï∞Â≠ó] - ËÆæÁΩÆ‰∫§ÊòìË¥πÁéá
- ËÆæÁΩÆÊ±áÁéá[Êï∞Â≠ó] - ËÆæÁΩÆÊ±áÁéá  
- ËÆæÁΩÆÂá∫Ê¨æÊ±áÁéá[Êï∞Â≠ó] - ËÆæÁΩÆÂá∫Ê¨æÊ±áÁéá
- ËÆæÁΩÆÊâãÁª≠Ë¥π[Êï∞Â≠ó] - ËÆæÁΩÆÂçïÁ¨îÊâãÁª≠Ë¥π
- ËÆæÁΩÆÊìç‰ΩúÂëò @Áî®Êà∑Âêç - Ê∑ªÂä†Êìç‰ΩúÂëò
- ‰∏äËØæ - ÂºÄÂßãËê•‰∏ö
- ‰∏ãËØæ - ÁªìÊùüËê•‰∏ö
- Êí§ÈîÄ[Ê∂àÊÅØID] - Êí§ÈîÄÊåáÂÆö‰∫§Êòì
- Âà†Èô§Ë¥¶Âçï - Âà†Èô§‰ªäÊó•ÊâÄÊúâ‰∫§ÊòìËÆ∞ÂΩï

‰∫§ÊòìÂëΩ‰ª§Ôºö
- +[ÈáëÈ¢ù] Êàñ +[ÈáëÈ¢ù] (Â§áÊ≥®) - ËÆ∞ÂΩïÂÖ•Ê¨æ
- ‰∏ãÂèë[USDTÈáëÈ¢ù] Êàñ ‰∏ãÂèë[USDTÈáëÈ¢ù] (Â§áÊ≥®) - ËÆ∞ÂΩï‰∏ãÂèë
- F[ÈáëÈ¢ù] Êàñ F[ÈáëÈ¢ù] (Â§áÊ≥®) - ‰ª£‰ªòËÆ°ÁÆó

Êü•ËØ¢ÂëΩ‰ª§Ôºö
- Áä∂ÊÄÅ - Êü•Áúã‰ªäÊó•Êä•Âëä
- [Êï∞Â≠ó][+-*/][Êï∞Â≠ó] - ËÆ°ÁÆóÂô®

Á§∫‰æãÔºö
- ËÆæÁΩÆË¥πÁéá2
- +1000000 Êàñ +1000000 (Â∑•ËµÑ)
- ‰∏ãÂèë59.39 Êàñ ‰∏ãÂèë-100 (Ë∞ÉÊï¥)
- F1000000 Êàñ F-500000 (ÈÄÄÊ¨æ)
- Êí§ÈîÄ126
- Âà†Èô§Ë¥¶Âçï
- 100+200
  `;
        bot.sendMessage(chatId, helpText);
        return;
      }

      if (text === "Âà†Èô§Ë¥¶Âçï") {
        if (!(await checkPermission(chatId, userId, msg))) {
          bot.sendMessage(chatId, "‚ùå Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÊåáÂÆöÊìç‰ΩúÂëòÂèØ‰ª•Âà†Èô§Ë¥¶Âçï");
          return;
        }
        deleteConfirmations.set(`${chatId}_${userId}`, Date.now());
        setTimeout(() => {
          deleteConfirmations.delete(`${chatId}_${userId}`);
        }, 5 * 60 * 1000);
        bot.sendMessage(
          chatId,
          "‚ö†Ô∏è ËØ∑ÈóÆÊòØÂê¶Á°ÆÂÆöË¶ÅÂà†Èô§‰ªäÊó•Ë¥¶ÂçïÔºü\n\nÊ≠§Êìç‰ΩúÂ∞ÜÂà†Èô§‰ªäÊó•ÊâÄÊúâ‰∫§ÊòìËÆ∞ÂΩï‰∏îÊó†Ê≥ïÊÅ¢Â§çÔºÅ\n\nËØ∑Âú®5ÂàÜÈíüÂÜÖÂõûÂ§ç„ÄåÁ°ÆÂÆö„Äç‰ª•Á°ÆËÆ§Âà†Èô§„ÄÇ"
        );
        return;
      }

      if (text === "Á°ÆÂÆö") {
        const confirmKey = `${chatId}_${userId}`;
        const confirmTime = deleteConfirmations.get(confirmKey);
        if (!confirmTime) {
          return;
        }
        if (Date.now() - confirmTime > 5 * 60 * 1000) {
          deleteConfirmations.delete(confirmKey);
          bot.sendMessage(chatId, "‚ùå Á°ÆËÆ§Ë∂ÖÊó∂ÔºåËØ∑ÈáçÊñ∞ÊâßË°åÂà†Èô§Ë¥¶ÂçïÂëΩ‰ª§");
          return;
        }
        deleteConfirmations.delete(confirmKey);
        try {
          const result = await deleteTodayTransactions(chatId);
          bot.sendMessage(
            chatId,
            `‚úÖ Â∑≤Âà†Èô§‰ªäÊó•Ë¥¶Âçï\n\nÂÖ±Âà†Èô§ ${result.deletedCount} Êù°‰∫§ÊòìËÆ∞ÂΩï`
          );
          const today = getTodayString();
          await SummaryService.rebuildSummaries(today, today);
          const report = await formatReport(chatId);
          sendReportWithButton(chatId, report);
        } catch (error) {
          console.error("Âà†Èô§Ë¥¶ÂçïÈîôËØØ:", error);
          bot.sendMessage(chatId, "‚ùå Âà†Èô§Ë¥¶ÂçïÊó∂Âá∫Áé∞ÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï");
        }
        return;
      }
    } catch (error) {
      console.error("Â§ÑÁêÜÊ∂àÊÅØÈîôËØØ:", error);
      bot.sendMessage(chatId, "‚ùå Â§ÑÁêÜÊ∂àÊÅØÊó∂Âá∫Áé∞ÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï");
    }
  });
};

// const setupCronJobs = () => {
//   cron.schedule(
//     "0 22 * * *",
//     async () => {
//       console.log("ÊâßË°åÊØèÊó•6ÁÇπÈáçÁΩÆ‰ªªÂä° (UTC+8)");

//       try {
//         const yesterday = moment().tz("Asia/Kuala_Lumpur");
//         if (yesterday.hour() < 6) {
//           yesterday.subtract(2, "days");
//         } else {
//           yesterday.subtract(1, "day");
//         }
//         const yesterdayStr = yesterday.format("YYYY-MM-DD");
//         const { start, end } = getBusinessDayRange(yesterdayStr);

//         const configs = await Config.find({});

//         for (const config of configs) {
//           const transactions = await Transaction.find({
//             chatId: config.chatId,
//             timestamp: {
//               $gte: start,
//               $lte: end,
//             },
//           });

//           if (transactions.length > 0) {
//             const stats = calculateStats(transactions, config.feeRate);
//             const dailyReport = new DailyReport({
//               chatId: config.chatId,
//               date: yesterdayStr,
//               totalInAmount: stats.totalInAmount,
//               totalInUsdt: stats.totalInUsdt,
//               totalOutUsdt: stats.totalOutUsdt,
//               transactionCount: {
//                 ÂÖ•Ê¨æ: stats.ÂÖ•Ê¨æ.length,
//                 ‰∏ãÂèë: stats.‰∏ãÂèë.length,
//                 ‰ª£‰ªò: stats.‰ª£‰ªò.length,
//               },
//               report: await formatReport(config.chatId),
//             });
//             await dailyReport.save();
//           }

//           config.lastReset = new Date();
//           await config.save();
//         }

//         console.log("ÊØèÊó•ÈáçÁΩÆ‰ªªÂä°ÂÆåÊàê");
//       } catch (error) {
//         console.error("ÊØèÊó•ÈáçÁΩÆ‰ªªÂä°ÈîôËØØ:", error);
//       }
//     },
//     {
//       scheduled: true,
//       timezone: "UTC",
//     }
//   );
// };

const convertToChatId = (urlChatId) => {
  if (
    urlChatId.toString().length >= 10 &&
    urlChatId.toString().startsWith("100")
  ) {
    return `-${urlChatId}`;
  }
  return `-${urlChatId}`;
};

function evaluateExpression(tokens) {
  let i = 1;
  while (i < tokens.length) {
    if (tokens[i] === "*" || tokens[i] === "/") {
      const left = parseFloat(tokens[i - 1]);
      const right = parseFloat(tokens[i + 1]);
      let result;

      if (tokens[i] === "*") {
        result = left * right;
      } else {
        if (right === 0) throw new Error("Èô§Êï∞‰∏çËÉΩ‰∏∫0");
        result = left / right;
      }
      tokens.splice(i - 1, 3, result.toString());
    } else {
      i += 2;
    }
  }
  i = 1;
  while (i < tokens.length) {
    const left = parseFloat(tokens[i - 1]);
    const right = parseFloat(tokens[i + 1]);
    let result;

    if (tokens[i] === "+") {
      result = left + right;
    } else {
      result = left - right;
    }
    tokens.splice(i - 1, 3, result.toString());
  }
  return parseFloat(tokens[0]);
}

router.get("/api/config/:chatId", async (req, res) => {
  try {
    const chatId = convertToChatId(req.params.chatId);
    const config = await getConfig(chatId);
    res.json(config);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get("/api/transactions/:chatId", async (req, res) => {
  try {
    const chatId = convertToChatId(req.params.chatId);
    const { startDate, endDate, date, page = 1, limit = 20, type } = req.query;

    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;

    let query = { chatId: chatId };
    if (type) {
      query.type = type;
    }

    if (startDate && endDate) {
      const startRange = getBusinessDayRange(startDate);
      const endRange = getBusinessDayRange(endDate);
      query.timestamp = {
        $gte: startRange.start,
        $lte: endRange.end,
      };
    } else if (date) {
      const { start, end } = getBusinessDayRange(date);
      query.timestamp = {
        $gte: start,
        $lte: end,
      };
    } else {
      const today = getTodayString();
      const { start, end } = getBusinessDayRange(today);
      query.timestamp = {
        $gte: start,
        $lte: end,
      };
    }

    const [transactions, total] = await Promise.all([
      Transaction.find(query)
        .sort({ timestamp: -1 })
        .skip(skip)
        .limit(limitNum)
        .lean(),
      Transaction.countDocuments(query),
    ]);

    res.json({
      data: transactions,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum),
        hasNext: pageNum < Math.ceil(total / limitNum),
        hasPrev: pageNum > 1,
      },
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
router.get("/api/report/:chatId", async (req, res) => {
  try {
    const chatId = convertToChatId(req.params.chatId);
    const { startDate, endDate, date } = req.query;
    let query = { chatId: chatId };
    if (startDate && endDate) {
      const startRange = getBusinessDayRange(startDate);
      const endRange = getBusinessDayRange(endDate);
      query.timestamp = {
        $gte: startRange.start,
        $lte: endRange.end,
      };
    } else if (date) {
      const { start, end } = getBusinessDayRange(date);
      query.timestamp = {
        $gte: start,
        $lte: end,
      };
    } else {
      const today = getTodayString();
      const { start, end } = getBusinessDayRange(today);
      query.timestamp = {
        $gte: start,
        $lte: end,
      };
    }
    const transactions = await Transaction.find(query).sort({ timestamp: 1 });
    const config = await getConfig(chatId);
    const stats = calculateStats(transactions, config.feeRate);
    const processedStats = {
      ...stats,
      totalActualUsdt: Math.floor(stats.totalActualUsdt * 100) / 100,
      totalOutUsdt: Math.floor(stats.totalOutUsdt * 100) / 100,
      totalPayoutAmount: stats.totalPayoutAmount,
      transactionCount: {
        ÂÖ•Ê¨æ: stats.ÂÖ•Ê¨æ.length,
        ‰∏ãÂèë: stats.‰∏ãÂèë.length,
        ‰ª£‰ªò: stats.‰ª£‰ªò.length,
      },
    };
    res.json({
      report: await formatReport(chatId),
      stats: processedStats,
      config,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get("/api/history/:chatId", async (req, res) => {
  try {
    const chatId = convertToChatId(req.params.chatId);
    const { limit = 30 } = req.query;
    const reports = await DailyReport.find({ chatId: chatId })
      .sort({ date: -1 })
      .limit(parseInt(limit));
    res.json(reports);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get("/api/stats/users/:chatId", async (req, res) => {
  try {
    const chatId = convertToChatId(req.params.chatId);
    const { startDate, endDate, date, page = 1, limit = 20 } = req.query;
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;
    let matchStage = { chatId: chatId };
    if (startDate && endDate) {
      const startRange = getBusinessDayRange(startDate);
      const endRange = getBusinessDayRange(endDate);
      matchStage.timestamp = {
        $gte: startRange.start,
        $lte: endRange.end,
      };
    } else if (date) {
      const { start, end } = getBusinessDayRange(date);
      matchStage.timestamp = {
        $gte: start,
        $lte: end,
      };
    } else {
      const today = getTodayString();
      const { start, end } = getBusinessDayRange(today);
      matchStage.timestamp = {
        $gte: start,
        $lte: end,
      };
    }
    const pipeline = [
      { $match: matchStage },
      { $match: { displayName: { $exists: true, $ne: null } } },
      {
        $group: {
          _id: "$displayName",
          username: { $first: "$username" },
          ÂÖ•Ê¨æcount: {
            $sum: { $cond: [{ $eq: ["$type", "ÂÖ•Ê¨æ"] }, 1, 0] },
          },
          ÂÖ•Ê¨æamount: {
            $sum: { $cond: [{ $eq: ["$type", "ÂÖ•Ê¨æ"] }, "$amount", 0] },
          },
          ÂÖ•Ê¨æusdt: {
            $sum: {
              $cond: [
                { $eq: ["$type", "ÂÖ•Ê¨æ"] },
                { $divide: ["$amount", "$rate"] },
                0,
              ],
            },
          },
          ‰∏ãÂèëcount: {
            $sum: { $cond: [{ $eq: ["$type", "‰∏ãÂèë"] }, 1, 0] },
          },
          ‰∏ãÂèëusdt: {
            $sum: { $cond: [{ $eq: ["$type", "‰∏ãÂèë"] }, "$usdt", 0] },
          },
          ‰ª£‰ªòcount: {
            $sum: { $cond: [{ $eq: ["$type", "‰ª£‰ªò"] }, 1, 0] },
          },
          ‰ª£‰ªòamount: {
            $sum: { $cond: [{ $eq: ["$type", "‰ª£‰ªò"] }, "$amount", 0] },
          },
          ‰ª£‰ªòusdt: {
            $sum: { $cond: [{ $eq: ["$type", "‰ª£‰ªò"] }, "$usdt", 0] },
          },
        },
      },
      {
        $project: {
          displayName: "$_id",
          username: 1,
          ÂÖ•Ê¨æ: {
            count: "$ÂÖ•Ê¨æcount",
            amount: "$ÂÖ•Ê¨æamount",
            usdt: "$ÂÖ•Ê¨æusdt",
          },
          ‰∏ãÂèë: {
            count: "$‰∏ãÂèëcount",
            usdt: "$‰∏ãÂèëusdt",
          },
          ‰ª£‰ªò: {
            count: "$‰ª£‰ªòcount",
            amount: "$‰ª£‰ªòamount",
            usdt: "$‰ª£‰ªòusdt",
          },
        },
      },
      { $sort: { displayName: 1 } },
      { $skip: skip },
      { $limit: limitNum },
    ];

    const [userStats, totalCount] = await Promise.all([
      Transaction.aggregate(pipeline),
      Transaction.distinct("displayName", matchStage),
    ]);

    res.json({
      data: userStats,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: totalCount.length,
        totalPages: Math.ceil(totalCount.length / limitNum),
        hasNext: pageNum < Math.ceil(totalCount.length / limitNum),
        hasPrev: pageNum > 1,
      },
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get("/api/stats/rates/:chatId", async (req, res) => {
  try {
    const chatId = convertToChatId(req.params.chatId);
    const { startDate, endDate, date } = req.query;

    let query = {
      chatId: chatId,
      type: "ÂÖ•Ê¨æ",
    };

    if (startDate && endDate) {
      const startRange = getBusinessDayRange(startDate);
      const endRange = getBusinessDayRange(endDate);
      query.timestamp = {
        $gte: startRange.start,
        $lte: endRange.end,
      };
    } else if (date) {
      const { start, end } = getBusinessDayRange(date);
      query.timestamp = {
        $gte: start,
        $lte: end,
      };
    } else {
      const today = getTodayString();
      const { start, end } = getBusinessDayRange(today);
      query.timestamp = {
        $gte: start,
        $lte: end,
      };
    }
    const transactions = await Transaction.find(query);
    const rateStats = {};

    transactions.forEach((t) => {
      if (!rateStats[t.rate]) {
        rateStats[t.rate] = {
          rate: t.rate,
          count: 0,
          amount: 0,
          usdt: 0,
        };
      }

      rateStats[t.rate].count++;
      rateStats[t.rate].amount += t.amount;
      rateStats[t.rate].usdt += t.amount / t.rate;
    });

    res.json(Object.values(rateStats));
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

process.on("SIGINT", () => {
  if (bot) {
    console.log("\nÊ≠£Âú®ÂÅúÊ≠¢ Bot...");
    const isProduction = process.env.NODE_ENV === "production";
    if (!isProduction) {
      bot.stopPolling();
    }
    process.exit(0);
  }
});

process.on("SIGTERM", () => {
  if (bot) {
    console.log("\nÊ≠£Âú®ÂÅúÊ≠¢ Bot...");
    const isProduction = process.env.NODE_ENV === "production";
    if (!isProduction) {
      bot.stopPolling();
    }
    process.exit(0);
  }
});
process.on("uncaughtException", (err) => {
  console.error("Êú™ÊçïËé∑ÁöÑÂºÇÂ∏∏:", err);
  if (bot) {
    bot.stopPolling();
  }
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("Êú™Â§ÑÁêÜÁöÑ Promise ÊãíÁªù:", reason);
});

router.init = () => {
  initializeBot();
  // setupCronJobs();
};

router.getBot = () => bot;

module.exports = router;
